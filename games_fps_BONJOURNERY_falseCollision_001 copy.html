<!DOCTYPE html>
<html lang="en">
<head>
    <title>three.js - Character Integration with Octree Collisions</title>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"/>
</head>
<body>
<div id="container"></div>
<audio id="ambientAudio" src="../ambientaudio.mp3" loop></audio> <!-- Audio element added here -->

<script type="importmap">
{
    "imports": {
        "three": "../build/three.module.js",
        "three/addons/": "./jsm/"
    }
}
</script>
<script type="module">
import * as THREE from "three";
import Stats from "three/addons/libs/stats.module.js";
import {GLTFLoader} from "three/addons/loaders/GLTFLoader.js";
import {Capsule} from "three/addons/math/Capsule.js";
//import {GUI} from "three/addons/libs/lil-gui.module.min.js";

//////////////////////////////////////////////////////////////////////////////////////////////////////
const clock = new THREE.Clock();
//////////////////////////////////////////////////////////////////////////////////////////////////////

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x88ccee);
scene.fog = new THREE.Fog(0x88ccee, 0, 200);

const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.set(0,6,0);
scene.add(camera); // Ensure the camera is added to the scene

const fillLight1 = new THREE.HemisphereLight(0x8dc1de, 0x00668d, 10.5);
      fillLight1.position.set(2, 50, 1);
      scene.add(fillLight1);

const directionalLight = new THREE.DirectionalLight(0xffffff, 2.5);
      directionalLight.position.set(-5, 50, -1);
      directionalLight.castShadow = true;
      directionalLight.shadow.camera.near = 0.01;
      directionalLight.shadow.camera.far = 500;
      directionalLight.shadow.camera.right = 120;
      directionalLight.shadow.camera.left = -120;
      directionalLight.shadow.camera.top = 120;
      directionalLight.shadow.camera.bottom = -120;
      directionalLight.shadow.mapSize.width = 2048;
      directionalLight.shadow.mapSize.height = 2048;
      directionalLight.shadow.radius = 6;
      directionalLight.shadow.bias = -0.001;

      directionalLight.shadow.camera.near = 1; // Default is 0.5
      directionalLight.shadow.camera.far = 500; // Adjust based on your scene size

      scene.add(directionalLight);

      const container = document.getElementById("container");
      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      //renderer.shadowMap.type = THREE.VSMShadowMap;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Default is THREE.PCFShadowMap

      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      container.appendChild(renderer.domElement);

//////////////////////////////////////////////////////////////////////////////////////////////////////
// Add at the beginning where other variables are declared
const raycaster = new THREE.Raycaster();
const downVector = new THREE.Vector3(0, -1, 0); // Ray pointing downwards
const offsetHeight = 1.5; // Desired distance between the camera and the ground

// Add at the beginning where other variables are declared
const forwardRaycaster = new THREE.Raycaster();
const forwardRayOffset = new THREE.Vector3(0, 4, 0); // 0.5 units above and 0.5 units in front of the character

//////////////////////////////////////////////////////////////////////////////////////////////////////

const loader = new GLTFLoader().setPath('./models/gltf/');
      loader.load("world3.glb", (gltf) => {
        scene.add(gltf.scene);
  // Traverse the scene and apply the material to every mesh
  gltf.scene.traverse((child) => {
    if (child.isMesh) {

      child.castShadow = true;
            child.receiveShadow = true;
            if (child.material.map) {
              child.material.map.anisotropy = 4;
            }
    }
  });
       /////
       /////

        animate();
      });

let mixer,idleAction, walkAction, character,playerCollider; // For character animations
loader.load('character2.glb', function (gltf) {
    character = gltf.scene;
        /////
        gltf.scene.traverse((child) => {
          if (child.isMesh) {
            child.castShadow = true;
            child.receiveShadow = true;
            if (child.material.map) {
              child.material.map.anisotropy = 4;
            }
          }
        });

    character.position.set(0, 0, 0); // Position the character on the grounds
    scene.add(character); // Add the character to the scene

    mixer = new THREE.AnimationMixer(character);
     idleAction = mixer.clipAction(gltf.animations[0]);
     walkAction = mixer.clipAction(gltf.animations[1]);
    idleAction.play(); // Play the idle animation by default
    // Setup the character collider and physics
    // ...character physics setup...
    camera.add(character);
    character.position.set(0, -1.45, -3); // Adjust so the character appears in front of the camera
    character.rotation.y -= Math.PI;
    // Since the character is a child of the camera, you only need to add the camera to the scene
        scene.add(camera);
}, undefined, function (error) {
    console.error(error);
});

/////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////

let lastMovementKey = '';
let rotatingLeft = false;
let rotatingRight = false;
let isWalking = false;
let movingForward = false;
let movingBackward = false;

document.addEventListener('keydown', function (event) {
    if (event.repeat) return; // Ignore auto-repeat

    switch (event.key) {
        case 'w':
            if (lastMovementKey !== 'w') {
                camera.translateZ(-0.2); // Move forward
                character.rotation.y = Math.PI; // Ensure character is facing forward
                lastMovementKey = 'w';
                movingForward = true;
            }
            break;
        case 's':
            if (lastMovementKey !== 's') {
                camera.translateZ(0.2); // Move backward, corrected direction
                character.rotation.y = 0; // Ensure character faces the camera (180 degrees)
                lastMovementKey = 's';

                movingBackward = true;
            }
            break;
        case 'a':
            rotatingLeft = true; // Enable continuous camera rotation
            if (lastMovementKey !== 'a') {
                character.rotation.y = -Math.PI / 2; // Rotate character 90 degrees left
                lastMovementKey = 'a';
            }
            break;
        case 'd':
            rotatingRight = true; // Enable continuous camera rotation
            if (lastMovementKey !== 'd') {
                character.rotation.y = Math.PI / 2; // Rotate character 90 degrees right
                lastMovementKey = 'd';
            }
            break;
    }
    // Start walking animation if not already walking
    if (!isWalking) {
        if (walkAction.isRunning()) {
            walkAction.stop();
        }
        walkAction.play();
        isWalking = true;
    }
});

document.addEventListener('keyup', function (event) {
    if (['w', 's', 'a', 'd'].includes(event.key)) {
        rotatingLeft = rotatingRight = false;
        isWalking = false;        
        movingForward = movingBackward = false;

        // Ensure walk action is stopped and idle action is restarted
        if (walkAction.isRunning()) {
            walkAction.stop();
        }
        idleAction.reset().play(); // Make sure to reset and play the idle action to avoid T-pose

        // Reset lastMovementKey only if the released key is the last movement key pressed
        if (lastMovementKey === event.key) {
            lastMovementKey = '';
        }
        
    }
});

/////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////

// Animation function
function animate() {
    requestAnimationFrame(animate);

    // Ground detection raycast
    const characterWorldPosition = new THREE.Vector3();
    character.getWorldPosition(characterWorldPosition); // Get the character's world position
    raycaster.set(characterWorldPosition, downVector); // Use the world position for the raycaster
    const groundIntersects = raycaster.intersectObjects(scene.children, true);
    if (groundIntersects.length > 0) {
        const closestIntersection = groundIntersects[0];
        const groundY = closestIntersection.point.y;
        camera.position.y = groundY + offsetHeight ; // Adjust the camera's Y position based on the ground level and desired offset
    }

    // Forward collision detection raycast
    const cameraDirection = new THREE.Vector3();
    camera.getWorldDirection(cameraDirection); // Get the forward direction of the camera
    raycaster.set(camera.position, cameraDirection); // Set the raycaster to shoot forward from the camera
    const forwardIntersects = raycaster.intersectObjects(scene.children, true);
    let canMoveForward = true;
    if (forwardIntersects.length > 0 && forwardIntersects[0].distance <= 4.5) {
        canMoveForward = false; // Prevent forward movement if there's an object within 3 units
    }

    // Character movement logic, taking into account ground and forward collision detection
    if (movingForward && canMoveForward) {
        camera.translateZ(-0.1); // Move forward if 'w' key is pressed and no forward collision
    }
    if (movingBackward) {
        camera.translateZ(0.1); // Move backward if 's' key is pressed
    }
    if (rotatingLeft) {
        camera.rotation.y += 0.02; // Rotate left if 'a' key is pressed
    }
    if (rotatingRight) {
        camera.rotation.y -= 0.02; // Rotate right if 'd' key is pressed
    }

    // Update the mixer if it exists
    const delta = clock.getDelta();
    if (mixer) mixer.update(delta);

    // Render the scene
    renderer.render(scene, camera);
}

// Play the audio when the page loads
document.addEventListener('DOMContentLoaded', function() {
    const ambientAudio = document.getElementById('ambientAudio');
    ambientAudio.play();
});


</script>
</body>
</html>